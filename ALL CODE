#include <iostream>
#include <vector>

using namespace std;
//#define getName(variable) #variable
//using namespace std;
//
//template<typename T>
//class Column;
//
////region Table
//class Table
//{
//public:
//    Table() = default;
//    template<class ...T>
//    Table(string tableName, Column<T>... columns) : _tableName(tableName)
//    {
//        Initialization(columns...);
//    }
//
//    template<class ...T>
//    void Initialization(Column<T>... columns)
//    {
//        int i = 0;
//
//        ([&](auto &row)
//        {
//            _columnName.emplace_back(static_cast<Column<T>>(row).name);
//            i++;
//        }(columns), ...);
//    }
//
//    size_t getColumnSize() const
//    {
//        return _columnName.size();
//    }
//
//    string getTableName() const
//    {
//        return _tableName;
//    }
//
//    string operator[](int i)
//    {
//        return _columnName.at(i);
//    }
//
//    virtual ~Table() = default;
//
//protected:
//    vector<string> _columnName;
//    string _tableName;
//};
////endregion
//
////region Condition
//class Condition
//{
//public:
//    Condition(const std::string &condition);
//
//    Condition(const Condition &condition);
//
//    Condition &operator&(Condition condition);
//
//    Condition &operator|(Condition condition);
//
//    std::string get() const;
//
//    std::string getWithoutScope() const;
//
//private:
//    std::string condition;
//};
//
//Condition::Condition(const std::string &condition)
//{
//    this->condition += condition;
//};
//
//Condition::Condition(const Condition &condition)
//{
//        this->condition = "(" + condition.getWithoutScope();
//}
//
//Condition &Condition::operator&(Condition condition)
//{
//    this->condition += ") AND (" + condition.getWithoutScope();
//    return *this;
//}
//
//Condition &Condition::operator|(Condition condition)
//{
//    string query = condition.getWithoutScope();
//    this->condition += " OR " + (query.starts_with('(') ? query.substr(1, query.length()) : query);
//    return *this;
//}
//
//std::string Condition::get() const
//{
//    return condition + ")";
//}
//
//std::string Condition::getWithoutScope() const
//{
//    return condition;
//}
////endregion
//
////std::string to_string(const std::string &value)
////{
////    return value;
////}
//
//enum class OrderSort : int
//{
//    ASC,
//    DESC
//};
//
//using
//enum OrderSort;
//
//class Sort
//{
//public:
//    Sort(string sort)
//    {
//        _sortedRow += sort;
//    }
//
//    Sort &operator&(Sort sort)
//    {
//        this->_sortedRow += ", " + sort.get();
//        return *this;
//    }
//
//    string get()
//    {
//        return _sortedRow;
//    }
//
//private:
//    string _sortedRow;
//};
//
//template<typename T>
//class Column final
//{
//public:
//    string name;
//    T type{};
//
//    Column() = default;
//
//    explicit Column(string name)
//            : name(name)
//    {
//    }
//
//    //region operators.
//    template<class V = Condition>
//    Condition operator>(V value)
//    {
//        using namespace std;
//        return {name + " > " /*+ to_string(value)*/};
//    }
//
//    template<class V = Condition>
//    Condition operator<(V value)
//    {
//        using namespace std;
//        return {name + " < " + to_string(value)};
//    }
//
//    template<class V = Condition>
//    Condition operator==(V value)
//    {
//        using namespace std;
//        return {name + " == " /*+ to_string(value)*/};
//    }
//
//    template<class V = Condition>
//    Condition operator!=(V value)
//    {
//        using namespace std;
//        return {name + " != " + to_string(value)};
//    }
//
//    Sort operator-(OrderSort order)
//    {
//        return {name + " " + ((order == OrderSort::ASC) ? "ASC" : "DESC")};
//    }
//    //endregion
//
//    virtual ~Column() = default;
//    string getS(){
//        return name;
//    }
//};
#include "LINQ/DatabaseComponent/includes/Table.h"
#include "LINQ/DatabaseComponent/includes/Column.h"
#include "LINQ/DatabaseComponent/includes/Sort.h"
#include "LINQ/DatabaseComponent/includes/Condition.h"

using namespace linq::db;

class invalid_column : public exception {};


class Select
{
public:
    template<typename ...T>
    explicit Select(Column<T>... rows)
    {
        int i = 0;

        ([&](auto &row)
        {
            _columnName.emplace_back(static_cast<Column<T>>(row).name);
            i++;
        }(rows), ...);
    }

    Select *from(Table table)
    {
        auto isRow = [&](string row) -> bool
        {
            for (int i = 0; i < table.getColumnSize(); i++)
            {
                if (row == table[i])
                {
                    return true;
                }
            }
            return false;
        };
        for (auto &i: _columnName)
        {
            if (!isRow(i))
            {
                throw invalid_column();
            }
        }
        createQuery(table.getTableName());
        return this;
    }

    string getQuery()
    {
        return _sqlQuery;
    }

    void createQuery(string tableName)
    {

        _sqlQuery = "SELECT " + _columnName[0];
        for (int i = 1; i < _columnName.size(); i++)
        {
            _sqlQuery += ", " + _columnName[i];
        }
        _sqlQuery += "\nFROM " + tableName;
    }

    Select *where(Condition condition)
    {
        _sqlQuery += "\nWHERE " + condition.get();
        return this;
    }

    Select *orderBy(Sort sort)
    {
        _sqlQuery += "\nORDER BY " + sort.get();
        return this;
    }

private:
    vector<string> _columnName;
    string _sqlQuery;

};


//#define getName(variable) #variable
//
//namespace linq::db
//{
//    class Condition
//    {
//    public:
//        Condition(const std::string &condition);
//
//        Condition(const Condition &condition);
//
//        Condition &operator&(Condition condition);
//
//        Condition &operator|(Condition condition);
//
//        std::string get() const;
//
//        std::string getWithoutScope() const;
//
//    private:
//        std::string condition{};
//    };
//}
//
//linq::db::Condition::Condition(const std::string &condition)
//{
//    this->condition += condition;
//}
//
//linq::db::Condition::Condition(const linq::db::Condition &condition)
//{
//    this->condition = "(" + condition.getWithoutScope();
//}
//
//linq::db::Condition &
//linq::db::Condition::operator&(linq::db::Condition condition)
//{
//    this->condition += ") AND (" + condition.getWithoutScope();
//    return *this;
//}
//
//linq::db::Condition &
//linq::db::Condition::operator|(linq::db::Condition condition)
//{
//    std::string query = condition.getWithoutScope();
//    this->condition += " OR " + (query.starts_with('(') ? query.substr(1, query.length()) : query);
//    return *this;
//}
//
//std::string linq::db::Condition::get() const
//{
//    return condition + ")";
//}
//
//std::string linq::db::Condition::getWithoutScope() const
//{
//    return condition;
//}
//
//namespace linq::db
//{
//    enum class OrderSort : int
//    {
//        ASC,
//        DESC
//    };
//
//    using
//    enum OrderSort;
//
//    class Sort
//    {
//    public:
//
//        Sort();
//
//        Sort(std::string sort);
//
//        Sort &operator&(Sort sort);
//
//        std::string get();
//
//    private:
//        std::string _sortedRow{};
//    };
//}
//
//linq::db::Sort::Sort(std::string sort)
//{
//    _sortedRow += sort;
//}
//
//linq::db::Sort &
//linq::db::Sort::operator&(Sort sort)
//{
//    this->_sortedRow += ", " + sort.get();
//    return *this;
//}
//
//std::string linq::db::Sort::get()
//{
//    return _sortedRow;
//}
//
//linq::db::Sort::Sort() = default;
//
//std::string to_string(const std::string &value)
//{
//    return value;
//}
//
//namespace linq::db
//{
//    template<typename T>
//    class Column final
//    {
//    public:
//        std::string name{};
//        T type{};
//
//        Column();
//
//        Column(std::string name);
//
//
//        template<typename V>
//        Condition operator>(V value);
//
//        template<typename V>
//        Condition operator<(V value);
//
//        template<typename V>
//        Condition operator==(V value);
//
//        template<typename V>
//        Condition operator!=(V value);
//
//        Sort operator-(OrderSort order);
//
//    };
//}
//
//template<typename T>
//linq::db::Column<T>::Column(std::string name) : name(std::move(name))
//{
//}
//
//template<typename T>
//template<typename V>
//linq::db::Condition
//linq::db::Column<T>::operator>(V value)
//{
//    using namespace std;
//    return {name + " > " + to_string(value)};
//}
//
//template<typename T>
//template<typename V>
//linq::db::Condition
//linq::db::Column<T>::operator<(V value)
//{
//    using namespace std;
//    return {name + " < " + to_string(value)};
//}
//
//template<typename T>
//template<typename V>
//linq::db::Condition
//linq::db::Column<T>::operator==(V value)
//{
//    using namespace std;
//    return {name + " == " + to_string(value)};
//}
//
//template<typename T>
//template<typename V>
//linq::db::Condition
//linq::db::Column<T>::operator!=(V value)
//{
//    using namespace std;
//    return {name + " != " +to_string(value)};
//}
//
//template<typename T>
//linq::db::Sort
//linq::db::Column<T>::operator-(db::OrderSort order)
//{
//    return {name + " " + ((order == OrderSort::ASC) ? "ASC" : "DESC")};
//}
//
//template<typename T>
//linq::db::Column<T>::Column() = default;
//
//
//namespace linq::db
//{
//    class Table
//    {
//    public:
//        Table();
//
//        template<class ...T>
//        Table(std::string tableName, Column<T>... columns);
//
//        template<class ...T>
//        void Initialization(Column<T>... columns);
//
//        size_t getColumnSize() const;
//
//        std::string getTableName() const;
//
//        std::string operator[](int i);
//
//
//    protected:
//        std::vector <std::string> _columnName{};
//        std::string _tableName{};
//    };
//}
//
//template<class... T>
//linq::db::Table::Table(std::string tableName, linq::db::Column<T>... columns) : _tableName(tableName)
//{
//    Initialization(columns...);
//}
//
//template<class... T>
//void linq::db::Table::Initialization(linq::db::Column<T>... columns)
//{
//    int i = 0;
//
//    ([&](auto &row)
//    {
//        _columnName.emplace_back(static_cast<Column<T>>(row).name);
//        i++;
//    }(columns), ...);
//}
//
//size_t linq::db::Table::getColumnSize() const {
//    return _columnName.size();
//}
//
//std::string linq::db::Table::getTableName() const
//{
//    return _tableName;
//}
//
//std::string linq::db::Table::operator[](int i)
//{
//    return _columnName.at(i);
//}
//
//linq::db::Table::Table() = default;

class OrderBy : public SqlQuery
{
public:
    OrderBy(string query, Sort sort) : SqlQuery(query), _sort(sort)
    {
    }

    std::string validateQuery() override
    {
        _sqlQuery += "\nORDER BY " + _sort.get();

        if (!contains("ORDER BY "))
        {
            throw InvalidQuery();
        }

        return _sqlQuery;
    }

private:
    Sort _sort;
};

class Where : public SqlQuery
{
public:
    Where(string query, Condition condition)
            : SqlQuery(query), _condition(condition)
    {
    }

    OrderBy orderBy(Sort sort)
    {
        return OrderBy(validateQuery(), sort);
    }

    std::string validateQuery() override
    {
        _sqlQuery += "\nWHERE " + _condition.get();

        if (!contains("WHERE "))
        {
            throw InvalidQuery();
        }

        return _sqlQuery;
    }

private:
    Condition _condition;
};

class From : public SqlQuery
{
public:
    From() = default;

    From(string query, Table table, vector<string> columnName)
            : SqlQuery(query), _table(table), _columnName(columnName)
    {
    }

    std::string validateQuery() override
    {
        auto isRow = [&](string row) -> bool
        {
            for (int i = 0; i < _table.getColumnSize(); i++)
            {
                if (row == _table[i])
                {
                    return true;
                }
            }
            return false;
        };
        for (auto &i: _columnName)
        {
            if (!isRow(i))
            {
                throw invalid_column();
            }
        }

        _sqlQuery += "\nFROM " + _table.getTableName();

        if (!contains("FROM "))
        {
            throw InvalidQuery();
        }

        return _sqlQuery;
    }

    Where where(Condition condition)
    {
        return Where(validateQuery(), condition);
    }

private:
    Table _table;
    vector<string> _columnName;
};

class Select1 : public SqlQuery
{
public:
    template<typename ...T>
    explicit Select1(Column<T>... rows)
    {
        int i = 0;

        ([&](auto &row)
        {
            _columnName.emplace_back(static_cast<Column<T>>(row).name);
            i++;
        }(rows), ...);
    }

    std::string validateQuery() override
    {
        _sqlQuery = "SELECT " + _columnName[0];
        for (int i = 1; i < _columnName.size(); ++i)
        {
            _sqlQuery += ", " + _columnName[i];
        }

        if (!contains("SELECT "))
        {
            throw InvalidQuery();
        }

        return _sqlQuery;
    }

    From from(Table table)
    {
        return From(validateQuery(), table, _columnName);
    }

private:
    vector<string> _columnName;
};